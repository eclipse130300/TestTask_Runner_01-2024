В процессе создания тестового задания использовалась следующая архитектура и паттерны проектирования:

Finite state machine (GameStateMachine)
Этапы инициализации приложения поделены на уникальные состояния - bootstrap, levelLoad, playerProgressLoad, GameLoop

Service Locator (AllServices)
Первичная инициализация приложения происходит на этапе bootstrap. 
В нем, мы регистрируем все необходимые нам сервисы и разрешаем зависимости.
Можно было бы использовать на этом этапе IoC&DI, но для простоты оставил самописное решение.

Component (IInteractable, Obstacle, PowerUpFlyer)
Игровые взаимодействия(подбор PowerUps) реализованы через паттерн компонент и Monobehaviour.
Композиция компонентов на GameObject позволила построить идеально расширяемую архитектуру.

EventBus (EventBus)
В качестве глобальной шины событий (GameplayStarted,GameplayFinished) в проекте используется EventBus. 
Невзирая на то, что подобный подход может глобально менять состояния приложения, 
при правильном использовании (модель publisher-subscriber, отправил событие и забыл)
он предоставляет довольно гибкое архитектурное решение, с минимальным количеством boilerplate кода из-за особенностей реализации.

Factory (GameFactory)
В проекте используется общая фабрика для создания и инициализации всех обьектов на сцене

Procedural Content Generation (LevelGeneratorService)
Так же, в качестве усложнения базового задания (showOff) реализовал создание уровня через процедурную генерацию.
В ней используются такие техники как PerlinNoise & Breadth-First search для создания правдоподобных процедурных уровней.